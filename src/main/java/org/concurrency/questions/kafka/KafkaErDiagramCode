@startuml
!theme plain

'----------------------
' Interfaces
'----------------------
interface IPublisher {
    + getId()
    + publish(topicId, message)
}
note right of IPublisher
  Strategy / Observer pattern:
  Abstract publisher interface.
  Allows multiple publishing strategies.
end note

interface ISubscriber {
    + getId()
    + onMessage(message)
}
note right of ISubscriber
  Strategy / Observer pattern:
  Abstract subscriber interface.
  Can implement different consuming strategies.
end note

'----------------------
' Core Entities
'----------------------
class Message {
    - message: String
    + getMessage(): String
}
note right of Message
  Immutable message payload.
  Represents a single message sent to a topic.
end note

class Topic {
    - topicId: String
    - topicName: String
    - messages: List<Message>
    + addMessage(message)
    + getMessageAt(index): Message
    + size(): int
}
note right of Topic
  Represents a Kafka-like topic.
  Stores messages in memory (CopyOnWriteArrayList).
  Composition: contains messages.
  Thread-safe for concurrent access.
end note

class TopicSubscriber {
    - topic: Topic
    - subscriber: ISubscriber
    - offset: AtomicInteger
    - lock: ReentrantLock
    - condition: Condition
    - consumedLog: List<String>
    + getTopic()
    + getSubscriber()
    + getOffset()
    + logConsumption(message)
    + getConsumedLog(): List<String>
}
note right of TopicSubscriber
  Tracks subscriber's read offset per topic.
  Maintains consumer log for messages consumed.
  Uses per-subscriber Lock/Condition for thread-safe waiting.
  Design pattern: Observer (Pub-Sub)
end note

class KafkaController {
    - topics: Map<String, Topic>
    - topicSubscribers: Map<String, List<TopicSubscriber>>
    - executor: ExecutorService
    - topicIdCounter: AtomicInteger
    - running: boolean
    + createTopic(topicName): Topic
    + subscribe(subscriber, topicId)
    + publish(publisher, topicId, message)
    + shutdown()
    + printConsumerLogs()
}
note right of KafkaController
  Orchestrates topics, subscribers, publishers.
  Uses ExecutorService for async delivery.
  Design pattern: Controller.
  Manages per-subscriber locks and notifications.
end note

'----------------------
' Concrete Implementations
'----------------------
class SimplePublisher {
    - id: String
    - controller: KafkaController
    + getId()
    + publish(topicId, message)
}
note right of SimplePublisher
  Concrete implementation of IPublisher.
  Publishes messages through KafkaController.
end note

class SimpleSubscriber {
    - id: String
    + getId()
    + onMessage(message)
}
note right of SimpleSubscriber
  Concrete implementation of ISubscriber.
  Receives messages and prints them.
  Messages are logged in TopicSubscriber.
end note

'----------------------
' Relationships
'----------------------
IPublisher <|.. SimplePublisher
ISubscriber <|.. SimpleSubscriber

TopicSubscriber --> Topic : references
TopicSubscriber --> ISubscriber : references
KafkaController --> Topic : manages
KafkaController --> TopicSubscriber : manages
SimplePublisher --> KafkaController : uses
KafkaController ..> ExecutorService : uses

Topic "1" o-- "many" Message : contains
Topic "1" o-- "many" TopicSubscriber : consumed by
@enduml
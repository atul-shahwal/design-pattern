@startuml
actor User
participant Cache
participant KeyBasedExecutor
participant CacheStorage
participant EvictionAlgorithm
participant ReadPolicy
participant WritePolicy
participant DBStorage

== Write Path ==
User -> Cache: updateData(key, value)
Cache -> KeyBasedExecutor: submitTask(key, task)
KeyBasedExecutor -> Cache: execute in key-specific thread

alt cache contains key
    Cache -> WritePolicy: write(key, value, cacheStorage, dbStorage)
    WritePolicy -> CacheStorage: put(key, value)
    WritePolicy -> DBStorage: write(key, value)
    Cache -> EvictionAlgorithm: keyAccessed(key)
else cache full
    Cache -> EvictionAlgorithm: evictKey()
    EvictionAlgorithm -> CacheStorage: remove(evictedKey)
    Cache -> WritePolicy: write(key, value, cacheStorage, dbStorage)
    WritePolicy -> CacheStorage: put(key, value)
    WritePolicy -> DBStorage: write(key, value)
    Cache -> EvictionAlgorithm: keyAccessed(key)
end

Cache --> User: CompletableFuture<Void>

== Read Path ==
User -> Cache: accessData(key)
Cache -> KeyBasedExecutor: submitTask(key, task)
KeyBasedExecutor -> Cache: execute in key-specific thread

alt cache hit
    Cache -> CacheStorage: get(key)
    Cache -> EvictionAlgorithm: keyAccessed(key)
    Cache --> User: CompletableFuture<Value>
else cache miss
    Cache -> ReadPolicy: read(key, cacheStorage, dbStorage)
    ReadPolicy -> DBStorage: read(key)
    alt key found in DB
        ReadPolicy -> CacheStorage: put(key, value)
        Cache -> EvictionAlgorithm: keyAccessed(key)
        Cache --> User: CompletableFuture<Value>
    else key not found
        Cache --> User: CompletableFuture<Error: Key not found>
    end
end
@enduml
